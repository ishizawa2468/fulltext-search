/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface Ticker {
  id?: number;
  updatedAt?: string;
  code?: string;
  name?: string;
  market?: string;
  sectorCode?: string;
  sector?: string;
  subsectorCode?: string;
  subsector?: string;
  scaleCode?: string;
  indexName?: string;
}

export interface SearchResult {
  name?: string;
}

export type SearchParams = {
query: string;
};

export const getById = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ticker>> => {
    
    
    return axios.default.get(
      `/api/tickers/${id}`,options
    );
  }


export const getGetByIdQueryKey = (id?: number,) => {
    return [`/api/tickers/${id}`] as const;
    }

    
export const getGetByIdQueryOptions = <TData = Awaited<ReturnType<typeof getById>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getById>>> = ({ signal }) => getById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getById>>>
export type GetByIdQueryError = AxiosError<unknown>


export function useGetById<TData = Awaited<ReturnType<typeof getById>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getById>>,
          TError,
          Awaited<ReturnType<typeof getById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetById<TData = Awaited<ReturnType<typeof getById>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getById>>,
          TError,
          Awaited<ReturnType<typeof getById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetById<TData = Awaited<ReturnType<typeof getById>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetById<TData = Awaited<ReturnType<typeof getById>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const update = (
    id: number,
    ticker: Ticker, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ticker>> => {
    
    
    return axios.default.put(
      `/api/tickers/${id}`,
      ticker,options
    );
  }



export const getUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: number;data: Ticker}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: number;data: Ticker}, TContext> => {

const mutationKey = ['update'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof update>>, {id: number;data: Ticker}> = (props) => {
          const {id,data} = props ?? {};

          return  update(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateMutationResult = NonNullable<Awaited<ReturnType<typeof update>>>
    export type UpdateMutationBody = Ticker
    export type UpdateMutationError = AxiosError<unknown>

    export const useUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: number;data: Ticker}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof update>>,
        TError,
        {id: number;data: Ticker},
        TContext
      > => {

      const mutationOptions = getUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const _delete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    
    
    return axios.default.delete(
      `/api/tickers/${id}`,options
    );
  }



export const getDeleteMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{id: number}, TContext> => {

const mutationKey = ['_delete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof _delete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  _delete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type _DeleteMutationResult = NonNullable<Awaited<ReturnType<typeof _delete>>>
    
    export type _DeleteMutationError = AxiosError<unknown>

    export const useDelete = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof _delete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof _delete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ticker[]>> => {
    
    
    return axios.default.get(
      `/api/tickers`,options
    );
  }


export const getGetAllQueryKey = () => {
    return [`/api/tickers`] as const;
    }

    
export const getGetAllQueryOptions = <TData = Awaited<ReturnType<typeof getAll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({ signal }) => getAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>
export type GetAllQueryError = AxiosError<unknown>


export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAll>>,
          TError,
          Awaited<ReturnType<typeof getAll>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAll>>,
          TError,
          Awaited<ReturnType<typeof getAll>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetAll<TData = Awaited<ReturnType<typeof getAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const create = (
    ticker: Ticker, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ticker>> => {
    
    
    return axios.default.post(
      `/api/tickers`,
      ticker,options
    );
  }



export const getCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: Ticker}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: Ticker}, TContext> => {

const mutationKey = ['create'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, {data: Ticker}> = (props) => {
          const {data} = props ?? {};

          return  create(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>
    export type CreateMutationBody = Ticker
    export type CreateMutationError = AxiosError<unknown>

    export const useCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: Ticker}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof create>>,
        TError,
        {data: Ticker},
        TContext
      > => {

      const mutationOptions = getCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const uploadCsv = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/ticker/seed`,undefined,{
        responseType: 'text',
    ...options,}
    );
  }



export const getUploadCsvMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadCsv>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uploadCsv>>, TError,void, TContext> => {

const mutationKey = ['uploadCsv'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadCsv>>, void> = () => {
          

          return  uploadCsv(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadCsvMutationResult = NonNullable<Awaited<ReturnType<typeof uploadCsv>>>
    
    export type UploadCsvMutationError = AxiosError<unknown>

    export const useUploadCsv = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadCsv>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadCsv>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getUploadCsvMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const search = (
    params: SearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SearchResult[]>> => {
    
    
    return axios.default.get(
      `/api/tickers/search`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchQueryKey = (params?: SearchParams,) => {
    return [`/api/tickers/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchQueryOptions = <TData = Awaited<ReturnType<typeof search>>, TError = AxiosError<unknown>>(params: SearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof search>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof search>>> = ({ signal }) => search(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof search>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchQueryResult = NonNullable<Awaited<ReturnType<typeof search>>>
export type SearchQueryError = AxiosError<unknown>


export function useSearch<TData = Awaited<ReturnType<typeof search>>, TError = AxiosError<unknown>>(
 params: SearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof search>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof search>>,
          TError,
          Awaited<ReturnType<typeof search>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearch<TData = Awaited<ReturnType<typeof search>>, TError = AxiosError<unknown>>(
 params: SearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof search>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof search>>,
          TError,
          Awaited<ReturnType<typeof search>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearch<TData = Awaited<ReturnType<typeof search>>, TError = AxiosError<unknown>>(
 params: SearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof search>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSearch<TData = Awaited<ReturnType<typeof search>>, TError = AxiosError<unknown>>(
 params: SearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof search>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const healthCheck = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/health`,{
        responseType: 'text',
    ...options,}
    );
  }


export const getHealthCheckQueryKey = () => {
    return [`/api/health`] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = AxiosError<unknown>


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
